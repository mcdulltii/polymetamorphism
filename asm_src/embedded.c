#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/syscall.h>

#define BLOCK_SIZE 8 //XTEA uses 64-bit blocks, 64 bits is 8 bytes

void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]);

void shellcode(void) {
    const char line[33] = "--------------------------------\n";
    const int line_len = 33;
    const char start_print[18] = "It's Morbin Time!\n";
    const int start_print_len = 18;
    const char wrong_print[25] = "Rejoice, my fellow Morbs\n";
    const int wrong_print_len = 25;
    const char correct_print[20] = "Time to get Morbed, ";
    const int correct_print_len = 20;
    // TISC{th1s_1s_n0t_th3_ac7u4l_fl4g_lM40}__b_____z__
    const char key[38] = { 0x7b, 0x66, 0x7c, 0x6c, 0x54, 0x5b, 0x47, 0x1e, 0x5c, 0x70, 0x1e, 0x5c, 0x70, 0x41, 0x1f, 0x5b, 0x70, 0x5b, 0x47, 0x1c, 0x70, 0x4e, 0x4c, 0x18, 0x5a, 0x1b, 0x43, 0x70, 0x49, 0x43, 0x1b, 0x48, 0x70, 0x43, 0x62, 0x1b, 0x1f, 0x52 };
    const int key_len = 38;
    const int input_len = 49;
    const char buf[48] = { 0x63, 0x74, 0x78, 0xa5, 0x8c, 0xa6, 0x56, 0x7e, 0xd3, 0xff, 0x7b, 0xf4, 0x90, 0x40, 0x2e, 0x42, 0x25, 0x7a, 0x49, 0xbd, 0x65, 0x52, 0x1f, 0xb, 0x20, 0xd4, 0xc3, 0xa6, 0x70, 0xaa, 0x12, 0xe, 0x6a, 0xb7, 0x6b, 0x72, 0xab, 0xc7, 0x5, 0x19, 0x25, 0x93, 0xad, 0x9b, 0xa1, 0x4c, 0x8a, 0x10 };
    const int buf_len = 48;
    char input[50];

    // Line Print
    asm (
            "lea %0, %%rsi\n"\
            "call _print"
            : : "m" (line), "d" (line_len)
        );

    // Start Print
    asm (
            "lea %0, %%rsi\n"\
            "call _print"
            : : "m" (start_print), "d" (start_print_len)
        );

    // Read input
    asm (
            "mov $50, %%rdx\n"\
            "lea %0, %%rsi\n"\
            "mov $2, %%rdi\n"\
            "xor %%rax, %%rax\n"\
            "syscall"
            : : "m" (input)
        );

    // Check input is read
    asm (
            "test %%rax, %%rax\n"\
            "jle EOF"
            : :
        );

    // XOR input with 47
    for (int i=0; i < 50; i++) {
        if ((input[i] >= '0' && input[i] <= '9') || (input[i] >= 'A' && input[i] <= '}'))
            input[i] ^= 47;
        else if (input[i] == '\0' || input[i] == '\n')
            break;
        else
            asm ( "jmp EOF" );
    }

    // strncmp key with input
    asm (
            "lea %0, %%rsi\n"\
            "lea %1, %%rdi\n"\
            "cld\n"\
            "repe cmpsb\n"\
            "jrcxz decode\n"
            : : "m" (key), "m" (input), "c" (key_len + 1)
        );

    // strncmp result fails
    asm (
            "lea %0, %%rsi\n"\
            "call _print"
            : : "m" (wrong_print), "d" (wrong_print_len)
        );

    // Exit function
    asm (
            "EOF:\n"\
            "    mov $0, %%rdi\n"\
            "    mov $60, %%rax\n"\
            "    syscall"
            : :
        );

    // Decoding function
    asm (
            "decode:"
            : :
        );

    // unsigned int dec_key[4] = { 0x5574, 0x646e, 0x4a55, 0x4d32 };
    unsigned int dec_key[4] = { (uint32_t)input[input_len - 3] << 8 | (uint32_t)input[15] ^ 47,
                                (0x64 << 8)                         | (uint32_t)input[13] ^ 47,
                                (0x4a << 8)                         | (uint32_t)input[input_len - 3],
                                (uint32_t)input[input_len - 9] << 8 | 0x32 };

    // Block decryption
    for (int i=0; i < (int) buf_len / BLOCK_SIZE; i++)
        decipher(32, (uint32_t*)(buf + i * BLOCK_SIZE), dec_key);

    // strncmp result succeeds
    asm (
            "lea %0, %%rsi\n"\
            "call _print"
            : : "m" (correct_print), "d" (correct_print_len)
        );

    // Print decrypted output
    asm (
            "lea %0, %%rsi\n"\
            "call _print\n"\
            "jmp EOF"
            : : "m" (buf), "d" (buf_len)
        );
}

// Print Function
__asm__ (
        "_print:\n"\
        "   mov $1, %rdi\n"\
        "   mov $1, %rax\n"\
        "   syscall\n"\
        "   ret"
    );

void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4])
{
//     unsigned int i;
//     uint32_t v0 = v[0], v1 = v[1], delta = 0x9E3779B9, sum = delta * num_rounds;
//     for (i = 0; i < num_rounds; i++)
//     {
//         v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);
//         sum -= delta;
//         v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);
//     }
//     v[0] = v0; v[1] = v1;
    asm ( ".byte 0x48,0xbb,0x89,0x7d,0xdc,0x90,0x90,0x90,0xeb,0x18,0xeb,0xf6,0x48,0xbb,0x48,0x8b,0x45,0xd0,0x8b,0x0,0xeb,0x2a,0x48,0xbb,0x48,0x89,0x55,0xc8,0x90,0x90,0xeb,0xee,0x48,0xbb,0x48,0x89,0x75,0xd0,0x90,0x90,0xeb,0xee,0x48,0xbb,0x48,0x8b,0x45,0xd0,0x90,0x90,0xeb,0x2,0x48,0xbb,0x8b,0x40,0x4,0x89,0x45,0xf4,0xeb,0xa,0x48,0xbb,0x89,0x45,0xf8,0x90,0x90,0x90,0xeb,0xe4,0xc7,0x45,0xec,0xb9,0x79,0x37,0x9e,0x48,0xbb,0x8c,0x7b,0xd0,0xed,0x8e,0xeb,0x6,0x56,0xeb,0xfb,0xe8,0x48,0xbb,0x8b,0x45,0xec,0x90,0x90,0x90,0xeb,0x2,0x48,0xbb,0xf,0xaf,0x45,0xdc,0x90,0x90,0xeb,0x2,0x48,0xbb,0x89,0x45,0xf0,0x90,0x90,0x90,0xeb,0x0,0xc7,0x45,0xfc,0x0,0x0,0x0,0x0,0x48,0xbb,0x64,0xeb,0x8,0x82,0xe7,0x76,0x71,0x25,0xeb,0xf7,0xe8,0xe9,0xfe,0x0,0x0,0x0,0x48,0xbb,0x8b,0x45,0xf8,0xc1,0xe0,0x4,0xeb,0x2c,0xeb,0xf6,0x48,0xbb,0x8b,0x45,0xf8,0x8d,0xc,0x2,0xeb,0x2,0x48,0xbb,0x8b,0x45,0xf0,0xc1,0xe8,0xb,0xeb,0x2,0x48,0xbb,0x89,0xc0,0x83,0xe0,0x3,0x90,0xeb,0x14,0x48,0xbb,0xc1,0xe8,0x5,0x31,0xc2,0x90,0xeb,0xda,0x48,0xbb,0x89,0xc2,0x8b,0x45,0xf8,0x90,0xeb,0xee,0x48,0x8d,0x14,0x85,0x0,0x0,0x0,0x0,0x48,0xbb,0x7e,0x67,0xb6,0xea,0xed,0xb7,0xeb,0x5,0xeb,0xfc,0xe8,0x48,0xbb,0x48,0x8b,0x45,0xc8,0x90,0x90,0xeb,0x2,0x48,0xbb,0x48,0x1,0xd0,0x8b,0x10,0x90,0xeb,0x20,0x48,0xbb,0x8b,0x45,0xf4,0xc1,0xe0,0x4,0xeb,0x2,0x48,0xbb,0x89,0xc2,0x8b,0x45,0xf4,0x90,0xeb,0x20,0x48,0xbb,0x31,0xc8,0x29,0x45,0xf4,0x90,0xeb,0xc,0x48,0xbb,0x8b,0x45,0xf0,0x1,0xd0,0x90,0xeb,0xee,0x48,0xbb,0x8b,0x45,0xec,0x29,0x45,0xf0,0xeb,0xd0,0x48,0xbb,0xc1,0xe8,0x5,0x31,0xc2,0x90,0xeb,0x2,0x48,0xbb,0x8b,0x45,0xf4,0x8d,0xc,0x2,0xeb,0x2,0x48,0xbb,0x8b,0x45,0xf0,0x83,0xe0,0x3,0xeb,0x14,0x48,0xbb,0x48,0x1,0xd0,0x8b,0x10,0x90,0xeb,0x2,0x48,0xbb,0x8b,0x45,0xf0,0x1,0xd0,0x90,0xeb,0x21,0x48,0x8d,0x14,0x85,0x0,0x0,0x0,0x0,0x48,0xbb,0xe9,0xeb,0xa,0xbc,0x6a,0xaa,0x13,0x9f,0xeb,0xf7,0xe8,0x48,0xbb,0x48,0x8b,0x45,0xc8,0x90,0x90,0xeb,0xcf,0x48,0xbb,0x31,0xc8,0x29,0x45,0xf8,0x90,0xeb,0x2,0x48,0xbb,0x83,0x45,0xfc,0x1,0x90,0x90,0xeb,0x0,0x48,0xbb,0x8b,0x45,0xfc,0x3b,0x45,0xdc,0xeb,0x2,0xeb,0xf6,0xf,0x82,0xf0,0xfe,0xff,0xff,0x48,0xbb,0x48,0x8b,0x45,0xd0,0x90,0x90,0xeb,0xe,0xeb,0xf6,0x48,0xbb,0x48,0x8b,0x45,0xd0,0x90,0x90,0xeb,0xc,0x48,0xbb,0x8b,0x55,0xf8,0x89,0x10,0x90,0xeb,0xee,0x48,0xbb,0x48,0x8d,0x50,0x4,0x90,0x90,0xeb,0x2,0x48,0xbb,0x8b,0x45,0xf4,0x89,0x2,0x90,0xeb,0x0" );
}

void END_SHELLCODE(void) {}

int main(void) {
    FILE* output = fopen("output.bin", "w");
    fwrite(shellcode, (uintptr_t)END_SHELLCODE - (uintptr_t)shellcode, 1, output);
    fclose(output);
//     shellcode();

    return 0;
}

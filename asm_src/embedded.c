#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/syscall.h>

#define BLOCK_SIZE 8 //XTEA uses 64-bit blocks, 64 bits is 8 bytes

void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]);

void shellcode(void) {
    const char start_print[18] = "It's Morbin Time!\n";
    const int start_print_len = 18;
    const char wrong_print[25] = "Rejoice, my fellow Morbs\n";
    const int wrong_print_len = 25;
    const char correct_print[20] = "Time to get Morbed, ";
    const int correct_print_len = 20;
    // TISC{th1s_1s_n0t_th3_ac7u4l_fl4g_lM40}_MJd_U2
    const char key[38] = { 'T','I','S','C','{','t','h','1','s','_','1','s','_','n','0','t','_','t','h','3','_','a','c','7','u','4','l','_','f','l','4','g','_','l','M','4','0','}' };
    const int key_len = 38;
    const int input_len = 45;
    const char buf[48] = { 0x63, 0x74, 0x78, 0xa5, 0x8c, 0xa6, 0x56, 0x7e, 0xd3, 0xff, 0x7b, 0xf4, 0x90, 0x40, 0x2e, 0x42, 0x25, 0x7a, 0x49, 0xbd, 0x65, 0x52, 0x1f, 0xb, 0x20, 0xd4, 0xc3, 0xa6, 0x70, 0xaa, 0x12, 0xe, 0x6a, 0xb7, 0x6b, 0x72, 0xab, 0xc7, 0x5, 0x19, 0x25, 0x93, 0xad, 0x9b, 0xa1, 0x4c, 0x8a, 0x10 };
    const int buf_len = 48;
    char input[50];

    // Start Print
    asm (
            "lea %0, %%rsi\n"\
            "call _print"
            : : "m" (start_print), "d" (start_print_len)
        );

    // Read input
    asm (
            "mov $50, %%rdx\n"\
            "lea %0, %%rsi\n"\
            "mov $2, %%rdi\n"\
            "xor %%rax, %%rax\n"\
            "syscall"
            : : "m" (input)
        );

    // Check input is read
    asm (
            "test %%rax, %%rax\n"\
            "jle EOF"
            : :
        );

    // strncmp key with input
    asm (
            "lea %0, %%rsi\n"\
            "lea %1, %%rdi\n"\
            "cld\n"\
            "repe cmpsb\n"\
            "jrcxz decode\n"
            : : "m" (key), "m" (input), "c" (key_len + 1)
        );

    // strncmp result fails
    asm (
            "lea %0, %%rsi\n"\
            "call _print"
            : : "m" (wrong_print), "d" (wrong_print_len)
        );

    // Exit function
    asm (
            "EOF:\n"\
            "    mov $0, %%rdi\n"\
            "    mov $60, %%rax\n"\
            "    syscall"
            : :
        );

    // Decoding loop
    asm (
            "decode:"
            : :
        );

    // unsigned int dec_key[4] = { 0x5574, 0x646e, 0x4a55, 0x4d32 };
    unsigned int dec_key[4] = { (uint32_t)input[input_len - 2] << 8 | (uint32_t)input[15], 
                                (uint32_t)input[input_len - 4] << 8 | (uint32_t)input[13], 
                                (uint32_t)input[input_len - 5] << 8 | (uint32_t)input[input_len - 2], 
                                (uint32_t)input[input_len - 6] << 8 | (uint32_t)input[input_len - 1]};

    // Mixup block decryption
//     for (int i=0; i < (int) buf_len / BLOCK_SIZE; i++)
//         decipher(32, (uint32_t*)(buf + i * BLOCK_SIZE), dec_key);
    decipher(32, (uint32_t*)(buf + 2 * BLOCK_SIZE), dec_key);
    decipher(32, (uint32_t*)(buf + 1 * BLOCK_SIZE), dec_key);
    decipher(32, (uint32_t*)(buf + 5 * BLOCK_SIZE), dec_key);
    decipher(32, (uint32_t*)(buf + 3 * BLOCK_SIZE), dec_key);
    decipher(32, (uint32_t*)(buf + 0 * BLOCK_SIZE), dec_key);
    decipher(32, (uint32_t*)(buf + 4 * BLOCK_SIZE), dec_key);

    // strncmp result succeeds
    asm (
            "lea %0, %%rsi\n"\
            "call _print"
            : : "m" (correct_print), "d" (correct_print_len)
        );

    // Print decrypted output
    asm (
            "lea %0, %%rsi\n"\
            "call _print\n"\
            "jmp EOF"
            : : "m" (buf), "d" (buf_len)
        );
}

// Print Function
__asm__ (
        "_print:\n"\
        "   mov $1, %rdi\n"\
        "   mov $1, %rax\n"\
        "   syscall\n"\
        "   ret"
    );

void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4])
{
//     unsigned int i;
//     uint32_t v0 = v[0], v1 = v[1], delta = 0x9E3779B9, sum = delta * num_rounds;
//     for (i = 0; i < num_rounds; i++)
//     {
//         v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);
//         sum -= delta;
//         v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);
//     }
//     v[0] = v0; v[1] = v1;
    asm ( ".byte 0x48,0xbb,0x89,0x7d,0xdc,0x90,0x90,0x90,0xeb,0x22,0xeb,0xf6,0x48,0xbb,0x89,0x45,0xf8,0x90,0x90,0x90,0xeb,0xc,0x48,0xbb,0x8b,0x40,0x4,0x89,0x45,0xf4,0xeb,0x28,0x48,0xbb,0x48,0x8b,0x45,0xd0,0x90,0x90,0xeb,0xee,0x48,0xbb,0x48,0x89,0x75,0xd0,0x90,0x90,0xeb,0xc,0x48,0xbb,0x48,0x8b,0x45,0xd0,0x8b,0x0,0xeb,0xd0,0x48,0xbb,0x48,0x89,0x55,0xc8,0x90,0x90,0xeb,0xee,0xc7,0x45,0xec,0xb9,0x79,0x37,0x9e,0x48,0xbb,0x13,0xeb,0xa,0xd2,0xd0,0xfa,0x67,0x44,0xeb,0xf7,0xe8,0x48,0xbb,0x8b,0x45,0xec,0x90,0x90,0x90,0xeb,0x2,0x48,0xbb,0xf,0xaf,0x45,0xdc,0x90,0x90,0xeb,0x2,0x48,0xbb,0x89,0x45,0xf0,0x90,0x90,0x90,0xeb,0x0,0xc7,0x45,0xfc,0x0,0x0,0x0,0x0,0x48,0xbb,0x1e,0xa6,0x28,0x7b,0x3a,0xeb,0x4,0xd2,0xeb,0xfb,0xe8,0xe9,0xfe,0x0,0x0,0x0,0x48,0xbb,0x8b,0x45,0xf8,0xc1,0xe0,0x4,0xeb,0x37,0xeb,0xf6,0x48,0xbb,0x8b,0x45,0xf8,0x8d,0xc,0x2,0xeb,0x2,0x48,0xbb,0x8b,0x45,0xf0,0xc1,0xe8,0xb,0xeb,0x2,0x48,0xbb,0x89,0xc0,0x83,0xe0,0x3,0x90,0xeb,0x0,0x48,0x8d,0x14,0x85,0x0,0x0,0x0,0x0,0x48,0xbb,0x17,0x99,0x31,0xa8,0x39,0x6a,0xeb,0x19,0xeb,0xfc,0xe8,0x48,0xbb,0x89,0xc2,0x8b,0x45,0xf8,0x90,0xeb,0x2,0x48,0xbb,0xc1,0xe8,0x5,0x31,0xc2,0x90,0xeb,0xbb,0x48,0xbb,0x48,0x8b,0x45,0xc8,0x90,0x90,0xeb,0xc,0x48,0xbb,0x8b,0x45,0xec,0x29,0x45,0xf0,0xeb,0x16,0x48,0xbb,0x48,0x1,0xd0,0x8b,0x10,0x90,0xeb,0x2,0x48,0xbb,0x8b,0x45,0xf0,0x1,0xd0,0x90,0xeb,0x16,0x48,0xbb,0x8b,0x45,0xf4,0xc1,0xe0,0x4,0xeb,0x2,0x48,0xbb,0x89,0xc2,0x8b,0x45,0xf4,0x90,0xeb,0xc,0x48,0xbb,0x31,0xc8,0x29,0x45,0xf4,0x90,0xeb,0xc6,0x48,0xbb,0xc1,0xe8,0x5,0x31,0xc2,0x90,0xeb,0x3f,0x48,0xbb,0x48,0x1,0xd0,0x8b,0x10,0x90,0xeb,0x2,0x48,0xbb,0x8b,0x45,0xf0,0x1,0xd0,0x90,0xeb,0x35,0x48,0x8d,0x14,0x85,0x0,0x0,0x0,0x0,0x48,0xbb,0xeb,0xb,0x1f,0x76,0xeb,0xfc,0xf8,0xe1,0xeb,0xf6,0xe8,0x48,0xbb,0x48,0x8b,0x45,0xc8,0x90,0x90,0xeb,0xcf,0x48,0xbb,0x8b,0x45,0xf0,0x83,0xe0,0x3,0xeb,0xd7,0x48,0xbb,0x8b,0x45,0xf4,0x8d,0xc,0x2,0xeb,0xee,0x48,0xbb,0x31,0xc8,0x29,0x45,0xf8,0x90,0xeb,0x2,0x48,0xbb,0x83,0x45,0xfc,0x1,0x90,0x90,0xeb,0x0,0x48,0xbb,0x8b,0x45,0xfc,0x3b,0x45,0xdc,0xeb,0x2,0xeb,0xf6,0xf,0x82,0xf0,0xfe,0xff,0xff,0x48,0xbb,0x48,0x8b,0x45,0xd0,0x90,0x90,0xeb,0x4,0xeb,0xf6,0x48,0xbb,0x8b,0x55,0xf8,0x89,0x10,0x90,0xeb,0x16,0x48,0xbb,0x48,0x8d,0x50,0x4,0x90,0x90,0xeb,0x2,0x48,0xbb,0x8b,0x45,0xf4,0x89,0x2,0x90,0xeb,0xc,0x48,0xbb,0x48,0x8b,0x45,0xd0,0x90,0x90,0xeb,0xe4,0x48,0xbb,0x5d,0xc3,0x90,0x90,0x90,0x90,0xeb,0x0" );
}

void END_SHELLCODE(void) {}

int main(void) {
    FILE* output = fopen("output.bin", "w");
    fwrite(shellcode, (uintptr_t)END_SHELLCODE - (uintptr_t)shellcode, 1, output);
    fclose(output);
//     shellcode();

    return 0;
}
